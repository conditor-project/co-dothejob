#!/bin/bash

# ------------------------------------------------------------------------------
# Charger la conf du module
# ------------------------------------------------------------------------------
REPCOURANT=$(cd $(dirname ${BASH_SOURCE[0]:-$0}) > /dev/null && pwd)
source "$REPCOURANT/../module.conf"

# ------------------------------------------------------------------------------
# Test/gestion de la ligne de commande
# ------------------------------------------------------------------------------
if [ $# -ne 2 ]; then
	echo "Crée les liens symboliques entre une arbo OUT d'un module et le IN du module courant"
	echo "usage : cree-liens-symboliques <ISTEX_SESSION> <DIR_OUT_D_UN_AUTRE_MODULE>"
	echo
	echo "<ISTEX_SESSION> : identifiant de la session à traiter"
	echo "<DIR_OUT_D_UN_AUTRE_MODULE> : répertoire 'OUT' du module parent (source), *sans* le nom de session"
	exit 1
else
	ISTEX_SESSION="$1"
	FROM="$2"
fi

# Construit 2 variables d'environnement pour permettre leur usage dans parallel
FROMDIR=`readlink -f $FROM`
if [ ! -d $FROMDIR ]; then
	echo "$FROMDIR n'est pas un répertoire ! Fin."
	exit 1
fi
export SYM_SOURCE="$FROMDIR/$ISTEX_SESSION"
export SYM_DESTINATION="$DIR_IN/$ISTEX_SESSION"

# ------------------------------------------------------------------------------
# Création de l'arbo complète dans IN (si elle n'existe pas)
# ------------------------------------------------------------------------------
if [ ! -d $DIR_IN/$ISTEX_SESSION ]; then
	echo "Le répertoire « $DIR_IN/$ISTEX_SESSION » est absent : installation de l'arborescence..."
	$DIR_SRC/installation $ISTEX_SESSION
fi

# ------------------------------------------------------------------------------
# Création des liens symboliques
# ------------------------------------------------------------------------------
echo "... création des liens symboliques pour la session « $ISTEX_SESSION »"
find $SYM_SOURCE -type f  | grep -v \.svn | $PARALLELCOMMANDLINE 'dir=$(splitdir {}); ln -s {} $SYM_DESTINATION/$dir/{/}; echo -n "."'

# Avant de rendre la main, on attend que tous les processus lancés ci-dessus
# rendent la main.
# Introduit pour permettre aux tests unitaires de "passer", sinon ils ont
# tendance à ne pas attendre et à planter...
# wait $!

# ------------------------------------------------------------------------------
# La fin, la vraie
# ------------------------------------------------------------------------------
echo "Fin."
exit 0
